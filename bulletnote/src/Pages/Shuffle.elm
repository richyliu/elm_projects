module Pages.Shuffle exposing (Model, Msg, init, subscriptions, toNavKey, update, view)

{-| Chooses random albums to display to the user
-}

import Album exposing (Album)
import Api
import Api.Endpoints as Endpoints
import Browser.Navigation as Nav
import Card exposing (viewCards)
import Girl exposing (Girl)
import Html exposing (..)
import Http
import Image exposing (Image)
import List.Extra as List
import Random exposing (Generator, Seed)
import Route
import WrappedPage exposing (PageContent)



-- MODEL


numAlbums : Int
numAlbums =
    4


type alias GirlAlbum =
    { girl : Girl
    , album : Album
    }


type State
    = Init RandomNums
    | WithAlbum WithAlbumState
    | LoadedAlbums (List ( GirlAlbum, Image ))
    | Error String


type alias WithAlbumState =
    { randomNums : RandomNums
    , girls : List Girl
    , girlAlbums : List GirlAlbum
    , images : List ( GirlAlbum, Image )
    }


{-| Random numbers generated by the seed, all length numAlbums
-}
type alias RandomNums =
    { girls : List Float
    , girlAlbums : List Float
    , images : List Float
    }


type alias Model =
    { navKey : Nav.Key
    , state : State
    }


init : Nav.Key -> Int -> ( Model, Cmd Msg )
init navKey seedNum =
    let
        seed =
            Random.initialSeed seedNum
    in
    ( { navKey = navKey
      , state = Init <| generateRandoms seed
      }
    , Api.getGirls GotGirls
    )


generateRandoms : Seed -> RandomNums
generateRandoms seed =
    let
        randomFloats : Generator (List Float)
        randomFloats =
            Random.list numAlbums (Random.float 0 1)

        ( girls, seed1 ) =
            Random.step randomFloats seed

        ( girlAlbums, seed2 ) =
            Random.step randomFloats seed1

        ( images, _ ) =
            Random.step randomFloats seed2
    in
    { girls = girls
    , girlAlbums = girlAlbums
    , images = images
    }



-- VIEW


view : Model -> PageContent Msg
view model =
    { title = "Shuffle"
    , iconButtons = []
    , content =
        case model.state of
            LoadedAlbums albums ->
                viewCards <|
                    List.map
                        (\( { girl, album }, image ) ->
                            { img = Endpoints.imageUrl girl.id album image
                            , title = girl.name ++ " " ++ Album.albumToString album
                            , subtitle = Nothing
                            , link = Route.Album girl.id album (Just image)
                            }
                        )
                        albums

            _ ->
                div [] [ text "loading" ]
    }



-- UPDATE


type Msg
    = GotGirls (Result Http.Error (List Girl))
      -- Got albums for one girl
    | GotAlbum Girl (Result Http.Error (List Album))
      -- Got images for one album of a girl
    | GotImages GirlAlbum (Result Http.Error (List Image))


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case ( msg, model.state ) of
        ( GotGirls result, Init randomNums ) ->
            case result of
                Ok girls ->
                    let
                        selectedGirls : List Girl
                        selectedGirls =
                            List.filterMap
                                ((rangeFloor <| List.length girls)
                                    >> (\i -> List.getAt i girls)
                                )
                                randomNums.girls

                        cmds =
                            List.map
                                (\girl -> Api.getAlbums girl.id <| GotAlbum girl)
                                selectedGirls
                    in
                    ( { model
                        | state =
                            WithAlbum
                                { girls = selectedGirls
                                , girlAlbums = []
                                , images = []
                                , randomNums = randomNums
                                }
                      }
                    , Cmd.batch cmds
                    )

                Err _ ->
                    ( { model | state = Error "Error in getting list of models" }
                    , Cmd.none
                    )

        ( GotAlbum girl result, WithAlbum albumState ) ->
            case result of
                Ok albums ->
                    let
                        selectedAlbum : Album
                        selectedAlbum =
                            albumState.randomNums.girlAlbums
                                |> List.indexedMap
                                    (\i num ->
                                        -- make sure we're using the right random num for choosing an album of this girl
                                        if List.getAt i albumState.girls == Just girl then
                                            Just num

                                        else
                                            Nothing
                                    )
                                |> List.filterMap identity
                                |> List.map (rangeFloor (List.length albums))
                                |> List.filterMap (\i -> List.getAt i albums)
                                |> List.head
                                |> Maybe.withDefault Album.first

                        girlAlbum : GirlAlbum
                        girlAlbum =
                            GirlAlbum girl selectedAlbum

                        newAlbums : List GirlAlbum
                        newAlbums =
                            -- sort for stable output/display
                            List.sortBy (.girl >> .name) (girlAlbum :: albumState.girlAlbums)
                    in
                    ( { model
                        | state =
                            WithAlbum
                                { albumState
                                    | girlAlbums = newAlbums
                                }
                      }
                    , Api.getImages girl.id selectedAlbum <| GotImages girlAlbum
                    )

                Err _ ->
                    ( { model
                        | state = Error <| "Error in getting list of albums for model name: " ++ girl.name
                      }
                    , Cmd.none
                    )

        ( GotImages girlAlbum result, WithAlbum albumState ) ->
            case result of
                Ok images ->
                    let
                        selectedImage : Image
                        selectedImage =
                            albumState.randomNums.images
                                |> List.indexedMap
                                    (\i num ->
                                        -- make sure we're using the right random num for choosing an image of this girlalbum
                                        if List.getAt i albumState.girlAlbums == Just girlAlbum then
                                            Just num

                                        else
                                            Nothing
                                    )
                                |> List.filterMap identity
                                |> List.map (rangeFloor (List.length images))
                                |> List.filterMap (\i -> List.getAt i images)
                                |> List.head
                                |> Maybe.withDefault Image.first

                        newImages : List ( GirlAlbum, Image )
                        newImages =
                            -- sort for stable output/display
                            List.sortBy (Tuple.first >> .girl >> .name) <|
                                ( girlAlbum
                                , selectedImage
                                )
                                    :: albumState.images
                    in
                    if List.length newImages == numAlbums then
                        ( { model | state = LoadedAlbums newImages }, Cmd.none )

                    else
                        ( { model
                            | state =
                                WithAlbum
                                    { albumState
                                        | images = newImages
                                    }
                          }
                        , Cmd.none
                        )

                Err _ ->
                    ( { model
                        | state = Error <| "Error in getting list of images for model name: " ++ girlAlbum.girl.name
                      }
                    , Cmd.none
                    )

        -- Ignore messages that were paired with the wrong state
        ( _, _ ) ->
            ( model, Cmd.none )


{-| Map a float from 0 to 1 to an int between 0 and limit

rangeFloor 4 0.2 == 0
rangeFloor 0 0 == 0
rangeFloor 10 0.5 == 5

-}
rangeFloor : Int -> Float -> Int
rangeFloor limit num =
    limit
        |> toFloat
        |> (*) num
        |> floor



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none



-- EXPORT


toNavKey : Model -> Nav.Key
toNavKey model =
    model.navKey
